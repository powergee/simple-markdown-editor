{"ast":null,"code":"var util = require('./util');\n\nmodule.exports = mathInline;\nconst tab = 9; // '\\t'\n\nconst space = 32; // ' '\n\nconst dollarSign = 36; // '$'\n\nconst digit0 = 48; // '0'\n\nconst digit9 = 57; // '9'\n\nconst backslash = 92; // '\\\\'\n\nconst classList = ['math', 'math-inline'];\nconst mathDisplay = 'math-display';\n\nfunction mathInline(options) {\n  const parser = this.Parser;\n  const compiler = this.Compiler;\n\n  if (util.isRemarkParser(parser)) {\n    attachParser(parser, options);\n  }\n\n  if (util.isRemarkCompiler(compiler)) {\n    attachCompiler(compiler, options);\n  }\n}\n\nfunction attachParser(parser, options) {\n  const proto = parser.prototype;\n  const inlineMethods = proto.inlineMethods;\n  mathInlineTokenizer.locator = locator;\n  proto.inlineTokenizers.math = mathInlineTokenizer;\n  inlineMethods.splice(inlineMethods.indexOf('text'), 0, 'math');\n\n  function locator(value, fromIndex) {\n    return value.indexOf('$', fromIndex);\n  }\n\n  function mathInlineTokenizer(eat, value, silent) {\n    const length = value.length;\n    let double = false;\n    let escaped = false;\n    let index = 0;\n    let previous;\n    let code;\n    let next;\n    let contentStart;\n    let contentEnd;\n    let valueEnd;\n    let content;\n\n    if (value.charCodeAt(index) === backslash) {\n      escaped = true;\n      index++;\n    }\n\n    if (value.charCodeAt(index) !== dollarSign) {\n      return;\n    }\n\n    index++; // Support escaped dollars.\n\n    if (escaped) {\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true;\n      }\n\n      return eat(value.slice(0, index))({\n        type: 'text',\n        value: '$'\n      });\n    }\n\n    if (value.charCodeAt(index) === dollarSign) {\n      double = true;\n      index++;\n    }\n\n    next = value.charCodeAt(index); // Opening fence cannot be followed by a space or a tab.\n\n    if (next === space || next === tab) {\n      return;\n    }\n\n    contentStart = index;\n\n    while (index < length) {\n      code = next;\n      next = value.charCodeAt(index + 1);\n\n      if (code === dollarSign) {\n        previous = value.charCodeAt(index - 1); // Closing fence cannot be preceded by a space or a tab, or followed by\n        // a digit.\n        // If a double marker was used to open, the closing fence must consist\n        // of two dollars as well.\n\n        if (previous !== space && previous !== tab && ( // eslint-disable-next-line no-self-compare\n        next !== next || next < digit0 || next > digit9) && (!double || next === dollarSign)) {\n          contentEnd = index - 1;\n          index++;\n\n          if (double) {\n            index++;\n          }\n\n          valueEnd = index;\n          break;\n        }\n      } else if (code === backslash) {\n        index++;\n        next = value.charCodeAt(index + 1);\n      }\n\n      index++;\n    }\n\n    if (valueEnd === undefined) {\n      return;\n    }\n    /* istanbul ignore if - never used (yet) */\n\n\n    if (silent) {\n      return true;\n    }\n\n    content = value.slice(contentStart, contentEnd + 1);\n    return eat(value.slice(0, valueEnd))({\n      type: 'inlineMath',\n      value: content,\n      data: {\n        hName: 'span',\n        hProperties: {\n          className: classList.concat(double && options.inlineMathDouble ? [mathDisplay] : [])\n        },\n        hChildren: [{\n          type: 'text',\n          value: content\n        }]\n      }\n    });\n  }\n}\n\nfunction attachCompiler(compiler) {\n  const proto = compiler.prototype;\n  proto.visitors.inlineMath = compileInlineMath;\n\n  function compileInlineMath(node) {\n    let fence = '$';\n    const classes = node.data && node.data.hProperties && node.data.hProperties.className || [];\n\n    if (classes.includes(mathDisplay)) {\n      fence = '$$';\n    }\n\n    return fence + node.value + fence;\n  }\n}","map":{"version":3,"sources":["/home/hyeon/Repositories/simple-markdown-editor/node_modules/remark-math/inline.js"],"names":["util","require","module","exports","mathInline","tab","space","dollarSign","digit0","digit9","backslash","classList","mathDisplay","options","parser","Parser","compiler","Compiler","isRemarkParser","attachParser","isRemarkCompiler","attachCompiler","proto","prototype","inlineMethods","mathInlineTokenizer","locator","inlineTokenizers","math","splice","indexOf","value","fromIndex","eat","silent","length","double","escaped","index","previous","code","next","contentStart","contentEnd","valueEnd","content","charCodeAt","slice","type","undefined","data","hName","hProperties","className","concat","inlineMathDouble","hChildren","visitors","inlineMath","compileInlineMath","node","fence","classes","includes"],"mappings":"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","sourcesContent":["var util = require('./util')\n\nmodule.exports = mathInline\n\nconst tab = 9 // '\\t'\nconst space = 32 // ' '\nconst dollarSign = 36 // '$'\nconst digit0 = 48 // '0'\nconst digit9 = 57 // '9'\nconst backslash = 92 // '\\\\'\n\nconst classList = ['math', 'math-inline']\nconst mathDisplay = 'math-display'\n\nfunction mathInline(options) {\n  const parser = this.Parser\n  const compiler = this.Compiler\n\n  if (util.isRemarkParser(parser)) {\n    attachParser(parser, options)\n  }\n\n  if (util.isRemarkCompiler(compiler)) {\n    attachCompiler(compiler, options)\n  }\n}\n\nfunction attachParser(parser, options) {\n  const proto = parser.prototype\n  const inlineMethods = proto.inlineMethods\n\n  mathInlineTokenizer.locator = locator\n\n  proto.inlineTokenizers.math = mathInlineTokenizer\n\n  inlineMethods.splice(inlineMethods.indexOf('text'), 0, 'math')\n\n  function locator(value, fromIndex) {\n    return value.indexOf('$', fromIndex)\n  }\n\n  function mathInlineTokenizer(eat, value, silent) {\n    const length = value.length\n    let double = false\n    let escaped = false\n    let index = 0\n    let previous\n    let code\n    let next\n    let contentStart\n    let contentEnd\n    let valueEnd\n    let content\n\n    if (value.charCodeAt(index) === backslash) {\n      escaped = true\n      index++\n    }\n\n    if (value.charCodeAt(index) !== dollarSign) {\n      return\n    }\n\n    index++\n\n    // Support escaped dollars.\n    if (escaped) {\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true\n      }\n\n      return eat(value.slice(0, index))({type: 'text', value: '$'})\n    }\n\n    if (value.charCodeAt(index) === dollarSign) {\n      double = true\n      index++\n    }\n\n    next = value.charCodeAt(index)\n\n    // Opening fence cannot be followed by a space or a tab.\n    if (next === space || next === tab) {\n      return\n    }\n\n    contentStart = index\n\n    while (index < length) {\n      code = next\n      next = value.charCodeAt(index + 1)\n\n      if (code === dollarSign) {\n        previous = value.charCodeAt(index - 1)\n\n        // Closing fence cannot be preceded by a space or a tab, or followed by\n        // a digit.\n        // If a double marker was used to open, the closing fence must consist\n        // of two dollars as well.\n        if (\n          previous !== space &&\n          previous !== tab &&\n          // eslint-disable-next-line no-self-compare\n          (next !== next || next < digit0 || next > digit9) &&\n          (!double || next === dollarSign)\n        ) {\n          contentEnd = index - 1\n\n          index++\n\n          if (double) {\n            index++\n          }\n\n          valueEnd = index\n          break\n        }\n      } else if (code === backslash) {\n        index++\n        next = value.charCodeAt(index + 1)\n      }\n\n      index++\n    }\n\n    if (valueEnd === undefined) {\n      return\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n      return true\n    }\n\n    content = value.slice(contentStart, contentEnd + 1)\n\n    return eat(value.slice(0, valueEnd))({\n      type: 'inlineMath',\n      value: content,\n      data: {\n        hName: 'span',\n        hProperties: {\n          className: classList.concat(\n            double && options.inlineMathDouble ? [mathDisplay] : []\n          )\n        },\n        hChildren: [{type: 'text', value: content}]\n      }\n    })\n  }\n}\n\nfunction attachCompiler(compiler) {\n  const proto = compiler.prototype\n\n  proto.visitors.inlineMath = compileInlineMath\n\n  function compileInlineMath(node) {\n    let fence = '$'\n    const classes =\n      (node.data && node.data.hProperties && node.data.hProperties.className) ||\n      []\n\n    if (classes.includes(mathDisplay)) {\n      fence = '$$'\n    }\n\n    return fence + node.value + fence\n  }\n}\n"]},"metadata":{},"sourceType":"script"}