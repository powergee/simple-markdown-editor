{"ast":null,"code":"const util = require('./util');\n\nmodule.exports = mathBlock;\nconst lineFeed = 10; //  '\\n'\n\nconst space = 32; // ' '\n\nconst dollarSign = 36; // '$'\n\nconst lineFeedChar = '\\n';\nconst dollarSignChar = '$';\nconst minFenceCount = 2;\nconst classList = ['math', 'math-display'];\n\nfunction mathBlock() {\n  const parser = this.Parser;\n  const compiler = this.Compiler;\n\n  if (util.isRemarkParser(parser)) {\n    attachParser(parser);\n  }\n\n  if (util.isRemarkCompiler(compiler)) {\n    attachCompiler(compiler);\n  }\n}\n\nfunction attachParser(parser) {\n  const proto = parser.prototype;\n  const blockMethods = proto.blockMethods;\n  const interruptParagraph = proto.interruptParagraph;\n  const interruptList = proto.interruptList;\n  const interruptBlockquote = proto.interruptBlockquote;\n  proto.blockTokenizers.math = mathBlockTokenizer;\n  blockMethods.splice(blockMethods.indexOf('fencedCode') + 1, 0, 'math'); // Inject math to interrupt rules\n\n  interruptParagraph.splice(interruptParagraph.indexOf('fencedCode') + 1, 0, ['math']);\n  interruptList.splice(interruptList.indexOf('fencedCode') + 1, 0, ['math']);\n  interruptBlockquote.splice(interruptBlockquote.indexOf('fencedCode') + 1, 0, ['math']);\n\n  function mathBlockTokenizer(eat, value, silent) {\n    var length = value.length;\n    var index = 0;\n    let code;\n    let content;\n    let lineEnd;\n    let lineIndex;\n    let openingFenceIndentSize;\n    let openingFenceSize;\n    let openingFenceContentStart;\n    let closingFence;\n    let closingFenceSize;\n    let lineContentStart;\n    let lineContentEnd; // Skip initial spacing.\n\n    while (index < length && value.charCodeAt(index) === space) {\n      index++;\n    }\n\n    openingFenceIndentSize = index; // Skip the fence.\n\n    while (index < length && value.charCodeAt(index) === dollarSign) {\n      index++;\n    }\n\n    openingFenceSize = index - openingFenceIndentSize; // Exit if there is not enough of a fence.\n\n    if (openingFenceSize < minFenceCount) {\n      return;\n    } // Skip spacing after the fence.\n\n\n    while (index < length && value.charCodeAt(index) === space) {\n      index++;\n    }\n\n    openingFenceContentStart = index; // Eat everything after the fence.\n\n    while (index < length) {\n      code = value.charCodeAt(index); // We don’t allow dollar signs here, as that could interfere with inline\n      // math.\n\n      if (code === dollarSign) {\n        return;\n      }\n\n      if (code === lineFeed) {\n        break;\n      }\n\n      index++;\n    }\n\n    if (value.charCodeAt(index) !== lineFeed) {\n      return;\n    }\n\n    if (silent) {\n      return true;\n    }\n\n    content = [];\n\n    if (openingFenceContentStart !== index) {\n      content.push(value.slice(openingFenceContentStart, index));\n    }\n\n    index++;\n    lineEnd = value.indexOf(lineFeedChar, index + 1);\n    lineEnd = lineEnd === -1 ? length : lineEnd;\n\n    while (index < length) {\n      closingFence = false;\n      lineContentStart = index;\n      lineContentEnd = lineEnd;\n      lineIndex = lineEnd;\n      closingFenceSize = 0; // First, let’s see if this is a valid closing fence.\n      // Skip trailing white space\n\n      while (lineIndex > lineContentStart && value.charCodeAt(lineIndex - 1) === space) {\n        lineIndex--;\n      } // Skip the fence.\n\n\n      while (lineIndex > lineContentStart && value.charCodeAt(lineIndex - 1) === dollarSign) {\n        closingFenceSize++;\n        lineIndex--;\n      } // Check if this is a valid closing fence line.\n\n\n      if (openingFenceSize <= closingFenceSize && value.indexOf(dollarSignChar, lineContentStart) === lineIndex) {\n        closingFence = true;\n        lineContentEnd = lineIndex;\n      } // Sweet, next, we need to trim the line.\n      // Skip initial spacing.\n\n\n      while (lineContentStart <= lineContentEnd && lineContentStart - index < openingFenceIndentSize && value.charCodeAt(lineContentStart) === space) {\n        lineContentStart++;\n      } // If this is a closing fence, skip final spacing.\n\n\n      if (closingFence) {\n        while (lineContentEnd > lineContentStart && value.charCodeAt(lineContentEnd - 1) === space) {\n          lineContentEnd--;\n        }\n      } // If this is a content line, or if there is content before the fence:\n\n\n      if (!closingFence || lineContentStart !== lineContentEnd) {\n        content.push(value.slice(lineContentStart, lineContentEnd));\n      }\n\n      if (closingFence) {\n        break;\n      }\n\n      index = lineEnd + 1;\n      lineEnd = value.indexOf(lineFeedChar, index + 1);\n      lineEnd = lineEnd === -1 ? length : lineEnd;\n    }\n\n    content = content.join('\\n');\n    return eat(value.slice(0, lineEnd))({\n      type: 'math',\n      value: content,\n      data: {\n        hName: 'div',\n        hProperties: {\n          className: classList.concat()\n        },\n        hChildren: [{\n          type: 'text',\n          value: content\n        }]\n      }\n    });\n  }\n}\n\nfunction attachCompiler(compiler) {\n  const proto = compiler.prototype;\n  proto.visitors.math = compileBlockMath;\n\n  function compileBlockMath(node) {\n    return '$$\\n' + node.value + '\\n$$';\n  }\n}","map":{"version":3,"sources":["/home/hyeon/Repositories/simple-markdown-editor/node_modules/remark-math/block.js"],"names":["util","require","module","exports","mathBlock","lineFeed","space","dollarSign","lineFeedChar","dollarSignChar","minFenceCount","classList","parser","Parser","compiler","Compiler","isRemarkParser","attachParser","isRemarkCompiler","attachCompiler","proto","prototype","blockMethods","interruptParagraph","interruptList","interruptBlockquote","blockTokenizers","math","mathBlockTokenizer","splice","indexOf","eat","value","silent","length","index","code","content","lineEnd","lineIndex","openingFenceIndentSize","openingFenceSize","openingFenceContentStart","closingFence","closingFenceSize","lineContentStart","lineContentEnd","charCodeAt","push","slice","join","type","data","hName","hProperties","className","concat","hChildren","visitors","compileBlockMath","node"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,QAAD,CAApB;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,SAAjB;AAEA,MAAMC,QAAQ,GAAG,EAAjB,C,CAAoB;;AACpB,MAAMC,KAAK,GAAG,EAAd,C,CAAiB;;AACjB,MAAMC,UAAU,GAAG,EAAnB,C,CAAsB;;AAEtB,MAAMC,YAAY,GAAG,IAArB;AACA,MAAMC,cAAc,GAAG,GAAvB;AAEA,MAAMC,aAAa,GAAG,CAAtB;AAEA,MAAMC,SAAS,GAAG,CAAC,MAAD,EAAS,cAAT,CAAlB;;AAEA,SAASP,SAAT,GAAqB;AACnB,QAAMQ,MAAM,GAAG,KAAKC,MAApB;AACA,QAAMC,QAAQ,GAAG,KAAKC,QAAtB;;AAEA,MAAIf,IAAI,CAACgB,cAAL,CAAoBJ,MAApB,CAAJ,EAAiC;AAC/BK,IAAAA,YAAY,CAACL,MAAD,CAAZ;AACD;;AAED,MAAIZ,IAAI,CAACkB,gBAAL,CAAsBJ,QAAtB,CAAJ,EAAqC;AACnCK,IAAAA,cAAc,CAACL,QAAD,CAAd;AACD;AACF;;AAED,SAASG,YAAT,CAAsBL,MAAtB,EAA8B;AAC5B,QAAMQ,KAAK,GAAGR,MAAM,CAACS,SAArB;AACA,QAAMC,YAAY,GAAGF,KAAK,CAACE,YAA3B;AACA,QAAMC,kBAAkB,GAAGH,KAAK,CAACG,kBAAjC;AACA,QAAMC,aAAa,GAAGJ,KAAK,CAACI,aAA5B;AACA,QAAMC,mBAAmB,GAAGL,KAAK,CAACK,mBAAlC;AAEAL,EAAAA,KAAK,CAACM,eAAN,CAAsBC,IAAtB,GAA6BC,kBAA7B;AAEAN,EAAAA,YAAY,CAACO,MAAb,CAAoBP,YAAY,CAACQ,OAAb,CAAqB,YAArB,IAAqC,CAAzD,EAA4D,CAA5D,EAA+D,MAA/D,EAT4B,CAW5B;;AACAP,EAAAA,kBAAkB,CAACM,MAAnB,CAA0BN,kBAAkB,CAACO,OAAnB,CAA2B,YAA3B,IAA2C,CAArE,EAAwE,CAAxE,EAA2E,CACzE,MADyE,CAA3E;AAGAN,EAAAA,aAAa,CAACK,MAAd,CAAqBL,aAAa,CAACM,OAAd,CAAsB,YAAtB,IAAsC,CAA3D,EAA8D,CAA9D,EAAiE,CAAC,MAAD,CAAjE;AACAL,EAAAA,mBAAmB,CAACI,MAApB,CAA2BJ,mBAAmB,CAACK,OAApB,CAA4B,YAA5B,IAA4C,CAAvE,EAA0E,CAA1E,EAA6E,CAC3E,MAD2E,CAA7E;;AAIA,WAASF,kBAAT,CAA4BG,GAA5B,EAAiCC,KAAjC,EAAwCC,MAAxC,EAAgD;AAC9C,QAAIC,MAAM,GAAGF,KAAK,CAACE,MAAnB;AACA,QAAIC,KAAK,GAAG,CAAZ;AACA,QAAIC,IAAJ;AACA,QAAIC,OAAJ;AACA,QAAIC,OAAJ;AACA,QAAIC,SAAJ;AACA,QAAIC,sBAAJ;AACA,QAAIC,gBAAJ;AACA,QAAIC,wBAAJ;AACA,QAAIC,YAAJ;AACA,QAAIC,gBAAJ;AACA,QAAIC,gBAAJ;AACA,QAAIC,cAAJ,CAb8C,CAe9C;;AACA,WAAOX,KAAK,GAAGD,MAAR,IAAkBF,KAAK,CAACe,UAAN,CAAiBZ,KAAjB,MAA4B7B,KAArD,EAA4D;AAC1D6B,MAAAA,KAAK;AACN;;AAEDK,IAAAA,sBAAsB,GAAGL,KAAzB,CApB8C,CAsB9C;;AACA,WAAOA,KAAK,GAAGD,MAAR,IAAkBF,KAAK,CAACe,UAAN,CAAiBZ,KAAjB,MAA4B5B,UAArD,EAAiE;AAC/D4B,MAAAA,KAAK;AACN;;AAEDM,IAAAA,gBAAgB,GAAGN,KAAK,GAAGK,sBAA3B,CA3B8C,CA6B9C;;AACA,QAAIC,gBAAgB,GAAG/B,aAAvB,EAAsC;AACpC;AACD,KAhC6C,CAkC9C;;;AACA,WAAOyB,KAAK,GAAGD,MAAR,IAAkBF,KAAK,CAACe,UAAN,CAAiBZ,KAAjB,MAA4B7B,KAArD,EAA4D;AAC1D6B,MAAAA,KAAK;AACN;;AAEDO,IAAAA,wBAAwB,GAAGP,KAA3B,CAvC8C,CAyC9C;;AACA,WAAOA,KAAK,GAAGD,MAAf,EAAuB;AACrBE,MAAAA,IAAI,GAAGJ,KAAK,CAACe,UAAN,CAAiBZ,KAAjB,CAAP,CADqB,CAGrB;AACA;;AACA,UAAIC,IAAI,KAAK7B,UAAb,EAAyB;AACvB;AACD;;AAED,UAAI6B,IAAI,KAAK/B,QAAb,EAAuB;AACrB;AACD;;AAED8B,MAAAA,KAAK;AACN;;AAED,QAAIH,KAAK,CAACe,UAAN,CAAiBZ,KAAjB,MAA4B9B,QAAhC,EAA0C;AACxC;AACD;;AAED,QAAI4B,MAAJ,EAAY;AACV,aAAO,IAAP;AACD;;AAEDI,IAAAA,OAAO,GAAG,EAAV;;AAEA,QAAIK,wBAAwB,KAAKP,KAAjC,EAAwC;AACtCE,MAAAA,OAAO,CAACW,IAAR,CAAahB,KAAK,CAACiB,KAAN,CAAYP,wBAAZ,EAAsCP,KAAtC,CAAb;AACD;;AAEDA,IAAAA,KAAK;AACLG,IAAAA,OAAO,GAAGN,KAAK,CAACF,OAAN,CAActB,YAAd,EAA4B2B,KAAK,GAAG,CAApC,CAAV;AACAG,IAAAA,OAAO,GAAGA,OAAO,KAAK,CAAC,CAAb,GAAiBJ,MAAjB,GAA0BI,OAApC;;AAEA,WAAOH,KAAK,GAAGD,MAAf,EAAuB;AACrBS,MAAAA,YAAY,GAAG,KAAf;AACAE,MAAAA,gBAAgB,GAAGV,KAAnB;AACAW,MAAAA,cAAc,GAAGR,OAAjB;AACAC,MAAAA,SAAS,GAAGD,OAAZ;AACAM,MAAAA,gBAAgB,GAAG,CAAnB,CALqB,CAOrB;AACA;;AACA,aACEL,SAAS,GAAGM,gBAAZ,IACAb,KAAK,CAACe,UAAN,CAAiBR,SAAS,GAAG,CAA7B,MAAoCjC,KAFtC,EAGE;AACAiC,QAAAA,SAAS;AACV,OAdoB,CAgBrB;;;AACA,aACEA,SAAS,GAAGM,gBAAZ,IACAb,KAAK,CAACe,UAAN,CAAiBR,SAAS,GAAG,CAA7B,MAAoChC,UAFtC,EAGE;AACAqC,QAAAA,gBAAgB;AAChBL,QAAAA,SAAS;AACV,OAvBoB,CAyBrB;;;AACA,UACEE,gBAAgB,IAAIG,gBAApB,IACAZ,KAAK,CAACF,OAAN,CAAcrB,cAAd,EAA8BoC,gBAA9B,MAAoDN,SAFtD,EAGE;AACAI,QAAAA,YAAY,GAAG,IAAf;AACAG,QAAAA,cAAc,GAAGP,SAAjB;AACD,OAhCoB,CAkCrB;AACA;;;AACA,aACEM,gBAAgB,IAAIC,cAApB,IACAD,gBAAgB,GAAGV,KAAnB,GAA2BK,sBAD3B,IAEAR,KAAK,CAACe,UAAN,CAAiBF,gBAAjB,MAAuCvC,KAHzC,EAIE;AACAuC,QAAAA,gBAAgB;AACjB,OA1CoB,CA4CrB;;;AACA,UAAIF,YAAJ,EAAkB;AAChB,eACEG,cAAc,GAAGD,gBAAjB,IACAb,KAAK,CAACe,UAAN,CAAiBD,cAAc,GAAG,CAAlC,MAAyCxC,KAF3C,EAGE;AACAwC,UAAAA,cAAc;AACf;AACF,OApDoB,CAsDrB;;;AACA,UAAI,CAACH,YAAD,IAAiBE,gBAAgB,KAAKC,cAA1C,EAA0D;AACxDT,QAAAA,OAAO,CAACW,IAAR,CAAahB,KAAK,CAACiB,KAAN,CAAYJ,gBAAZ,EAA8BC,cAA9B,CAAb;AACD;;AAED,UAAIH,YAAJ,EAAkB;AAChB;AACD;;AAEDR,MAAAA,KAAK,GAAGG,OAAO,GAAG,CAAlB;AACAA,MAAAA,OAAO,GAAGN,KAAK,CAACF,OAAN,CAActB,YAAd,EAA4B2B,KAAK,GAAG,CAApC,CAAV;AACAG,MAAAA,OAAO,GAAGA,OAAO,KAAK,CAAC,CAAb,GAAiBJ,MAAjB,GAA0BI,OAApC;AACD;;AAEDD,IAAAA,OAAO,GAAGA,OAAO,CAACa,IAAR,CAAa,IAAb,CAAV;AAEA,WAAOnB,GAAG,CAACC,KAAK,CAACiB,KAAN,CAAY,CAAZ,EAAeX,OAAf,CAAD,CAAH,CAA6B;AAClCa,MAAAA,IAAI,EAAE,MAD4B;AAElCnB,MAAAA,KAAK,EAAEK,OAF2B;AAGlCe,MAAAA,IAAI,EAAE;AACJC,QAAAA,KAAK,EAAE,KADH;AAEJC,QAAAA,WAAW,EAAE;AAACC,UAAAA,SAAS,EAAE5C,SAAS,CAAC6C,MAAV;AAAZ,SAFT;AAGJC,QAAAA,SAAS,EAAE,CAAC;AAACN,UAAAA,IAAI,EAAE,MAAP;AAAenB,UAAAA,KAAK,EAAEK;AAAtB,SAAD;AAHP;AAH4B,KAA7B,CAAP;AASD;AACF;;AAED,SAASlB,cAAT,CAAwBL,QAAxB,EAAkC;AAChC,QAAMM,KAAK,GAAGN,QAAQ,CAACO,SAAvB;AAEAD,EAAAA,KAAK,CAACsC,QAAN,CAAe/B,IAAf,GAAsBgC,gBAAtB;;AAEA,WAASA,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,WAAO,SAASA,IAAI,CAAC5B,KAAd,GAAsB,MAA7B;AACD;AACF","sourcesContent":["const util = require('./util')\n\nmodule.exports = mathBlock\n\nconst lineFeed = 10 //  '\\n'\nconst space = 32 // ' '\nconst dollarSign = 36 // '$'\n\nconst lineFeedChar = '\\n'\nconst dollarSignChar = '$'\n\nconst minFenceCount = 2\n\nconst classList = ['math', 'math-display']\n\nfunction mathBlock() {\n  const parser = this.Parser\n  const compiler = this.Compiler\n\n  if (util.isRemarkParser(parser)) {\n    attachParser(parser)\n  }\n\n  if (util.isRemarkCompiler(compiler)) {\n    attachCompiler(compiler)\n  }\n}\n\nfunction attachParser(parser) {\n  const proto = parser.prototype\n  const blockMethods = proto.blockMethods\n  const interruptParagraph = proto.interruptParagraph\n  const interruptList = proto.interruptList\n  const interruptBlockquote = proto.interruptBlockquote\n\n  proto.blockTokenizers.math = mathBlockTokenizer\n\n  blockMethods.splice(blockMethods.indexOf('fencedCode') + 1, 0, 'math')\n\n  // Inject math to interrupt rules\n  interruptParagraph.splice(interruptParagraph.indexOf('fencedCode') + 1, 0, [\n    'math'\n  ])\n  interruptList.splice(interruptList.indexOf('fencedCode') + 1, 0, ['math'])\n  interruptBlockquote.splice(interruptBlockquote.indexOf('fencedCode') + 1, 0, [\n    'math'\n  ])\n\n  function mathBlockTokenizer(eat, value, silent) {\n    var length = value.length\n    var index = 0\n    let code\n    let content\n    let lineEnd\n    let lineIndex\n    let openingFenceIndentSize\n    let openingFenceSize\n    let openingFenceContentStart\n    let closingFence\n    let closingFenceSize\n    let lineContentStart\n    let lineContentEnd\n\n    // Skip initial spacing.\n    while (index < length && value.charCodeAt(index) === space) {\n      index++\n    }\n\n    openingFenceIndentSize = index\n\n    // Skip the fence.\n    while (index < length && value.charCodeAt(index) === dollarSign) {\n      index++\n    }\n\n    openingFenceSize = index - openingFenceIndentSize\n\n    // Exit if there is not enough of a fence.\n    if (openingFenceSize < minFenceCount) {\n      return\n    }\n\n    // Skip spacing after the fence.\n    while (index < length && value.charCodeAt(index) === space) {\n      index++\n    }\n\n    openingFenceContentStart = index\n\n    // Eat everything after the fence.\n    while (index < length) {\n      code = value.charCodeAt(index)\n\n      // We don’t allow dollar signs here, as that could interfere with inline\n      // math.\n      if (code === dollarSign) {\n        return\n      }\n\n      if (code === lineFeed) {\n        break\n      }\n\n      index++\n    }\n\n    if (value.charCodeAt(index) !== lineFeed) {\n      return\n    }\n\n    if (silent) {\n      return true\n    }\n\n    content = []\n\n    if (openingFenceContentStart !== index) {\n      content.push(value.slice(openingFenceContentStart, index))\n    }\n\n    index++\n    lineEnd = value.indexOf(lineFeedChar, index + 1)\n    lineEnd = lineEnd === -1 ? length : lineEnd\n\n    while (index < length) {\n      closingFence = false\n      lineContentStart = index\n      lineContentEnd = lineEnd\n      lineIndex = lineEnd\n      closingFenceSize = 0\n\n      // First, let’s see if this is a valid closing fence.\n      // Skip trailing white space\n      while (\n        lineIndex > lineContentStart &&\n        value.charCodeAt(lineIndex - 1) === space\n      ) {\n        lineIndex--\n      }\n\n      // Skip the fence.\n      while (\n        lineIndex > lineContentStart &&\n        value.charCodeAt(lineIndex - 1) === dollarSign\n      ) {\n        closingFenceSize++\n        lineIndex--\n      }\n\n      // Check if this is a valid closing fence line.\n      if (\n        openingFenceSize <= closingFenceSize &&\n        value.indexOf(dollarSignChar, lineContentStart) === lineIndex\n      ) {\n        closingFence = true\n        lineContentEnd = lineIndex\n      }\n\n      // Sweet, next, we need to trim the line.\n      // Skip initial spacing.\n      while (\n        lineContentStart <= lineContentEnd &&\n        lineContentStart - index < openingFenceIndentSize &&\n        value.charCodeAt(lineContentStart) === space\n      ) {\n        lineContentStart++\n      }\n\n      // If this is a closing fence, skip final spacing.\n      if (closingFence) {\n        while (\n          lineContentEnd > lineContentStart &&\n          value.charCodeAt(lineContentEnd - 1) === space\n        ) {\n          lineContentEnd--\n        }\n      }\n\n      // If this is a content line, or if there is content before the fence:\n      if (!closingFence || lineContentStart !== lineContentEnd) {\n        content.push(value.slice(lineContentStart, lineContentEnd))\n      }\n\n      if (closingFence) {\n        break\n      }\n\n      index = lineEnd + 1\n      lineEnd = value.indexOf(lineFeedChar, index + 1)\n      lineEnd = lineEnd === -1 ? length : lineEnd\n    }\n\n    content = content.join('\\n')\n\n    return eat(value.slice(0, lineEnd))({\n      type: 'math',\n      value: content,\n      data: {\n        hName: 'div',\n        hProperties: {className: classList.concat()},\n        hChildren: [{type: 'text', value: content}]\n      }\n    })\n  }\n}\n\nfunction attachCompiler(compiler) {\n  const proto = compiler.prototype\n\n  proto.visitors.math = compileBlockMath\n\n  function compileBlockMath(node) {\n    return '$$\\n' + node.value + '\\n$$'\n  }\n}\n"]},"metadata":{},"sourceType":"script"}